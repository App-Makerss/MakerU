//
//  GenericsDAO.swift
//  MakerU
//
//  Created by Bruno Cardoso Ambrosio on 08/10/20.
//

import Foundation
import CloudKit

protocol GenericsDAO where Self: CloudKitEncodable {
    func delete(id: String)
    func update(entity: ManagedEntity, completion: ((ManagedEntity?,Error?) -> ())?)
    func save(entity: ManagedEntity, completion:  ((ManagedEntity?,Error?) -> ())?)
    func find(byId id: String, completion:  @escaping (ManagedEntity?,Error?) -> ())
    func listAll(by predicate: NSPredicate, sortBy sortDescriptors: [String: Bool], completion: @escaping ([ManagedEntity]?, Error?) -> ())
}

extension GenericsDAO {
    
    /// Saves a ManagedEntity(informed by the DAO implementing it) on the cloudKit
    /// - Parameter entity: entity to be saved
    /// - Returns:  the entity with the ID generated by the save process
    func save(entity: ManagedEntity, completion: ((ManagedEntity?,Error?) -> ())?) {
        var newEntity = entity
        //generates a record based on the entity
        guard let record = encodeToRecord(fromEntity: entity) else {return}
        //sets the entity id based on recordName
        newEntity.id = record.recordID.recordName
        
        //saves the new record to cloudkit
        DatabaseAccess.shared.publicDB.save(record) { (record, error) in
            if let error = error {
                completion?(nil, error)
            }else if
                let record = record,
                let entity = decode(fromRecord: record) {
                print("saved")
                completion?(entity, error)
            }
        }
    }
    
    
    /// Updates a ManagedEntity(informed by the DAO implementing it) on the cloudKit
    /// - Parameter entity: entity with values to be used to update it on cloudkit
    func update(entity: ManagedEntity, completion: ((ManagedEntity?,Error?) -> ())?) {
        let recID = CKRecord.ID(recordName: entity.id!)
        //fetches on database using the id
        DatabaseAccess.shared.publicDB.fetch(withRecordID: recID) { (foundRec, err) in
            if let err = err {
                print(err.localizedDescription)
            }else {
                //if the record was found, fills it with the entity (updating it)
                guard let rec = foundRec,
                      let updatedRec = fillRecord(withEntity: entity, rec: rec) else {return}
                
                //saves the update to cloudkit
                DatabaseAccess.shared.publicDB.save(updatedRec) { (recSaved, err) in
                    if err != nil {
                        completion?(nil, err)
                    }else if
                        let record = recSaved,
                        let entity = decode(fromRecord: record) {
                        print("updated")
                        completion?(entity, err)
                    }
                }
            }
        }
    }
    
    
    /// Deletes  a CKRecord based on an id passed (all entity has the id attributte)
    /// - Parameter id: id that will be deleted of cloudKit
    func delete(id: String) {
        let recID = CKRecord.ID(recordName: id)
        DatabaseAccess.shared.publicDB.delete(withRecordID: recID) { (_, error) in
            if error != nil {
                print(error!.localizedDescription)
            }else {
                print("\(recID) deleted")
            }
        }
    }
    
    func find(byId id: String, completion:  @escaping (ManagedEntity?, Error?) -> ()) {
        let recID = CKRecord.ID(recordName: id)
        DatabaseAccess.shared.publicDB.fetch(withRecordID: recID) { (ckrecord, error) in 
            
            guard let rec = ckrecord else {return}
            completion(decode(fromRecord: rec), error)
        }
    }
    
    func listAll(by predicate: NSPredicate, sortBy sortDescriptors: [String: Bool] = [:], completion: @escaping ([ManagedEntity]?, Error?) -> ()) {
        var descriptors: [CKLocationSortDescriptor] = []
        sortDescriptors.forEach { (key, isAscending) in
            descriptors.append(CKLocationSortDescriptor(key: key, ascending: isAscending))
        }
        let query = CKQuery(recordType: referenceName, predicate: predicate)
        query.sortDescriptors = descriptors
        let op = CKQueryOperation(query: query )
        var list: [ManagedEntity] = []
        
        op.recordFetchedBlock = { record in
            if let element = decode(fromRecord: record) {
                list.append(element)
            }
        }
        op.queryCompletionBlock = { cursor, error in
            if let error = error {
                completion(nil, error)
            }else {
                completion(list, nil)
            }
        }
        DatabaseAccess.shared.publicDB.add(op)
    }
    
}
